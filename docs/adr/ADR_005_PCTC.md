üìÑ ADR 005: Semantic Correspondence & Temporal Consistency (PCTC)Status: Aceito (Target: v2.7)Data: 09/02/2026Contexto: Resolu√ß√£o de alucina√ß√µes anat√¥micas e instabilidade de cor entre p√°ginas (Flickering).Depend√™ncias: ADR 004 (SAM 2.1 Segmentation) deve estar implementado.Hardware Alvo: NVIDIA RTX 3060 (12GB VRAM)1. O ProblemaMesmo com a segmenta√ß√£o precisa do ADR 004 (SAM 2.1), o pipeline atual sofre de duas limita√ß√µes fundamentais inerentes ao design do IP-Adapter e do SDXL:Cegueira Anat√¥mica (Pose Mismatch):O SAM garante que a tinta n√£o vaze para fora do personagem, mas n√£o controla onde os elementos internos (olhos, boca, ins√≠gnias) s√£o desenhados.Exemplo: Se a refer√™ncia √© frontal e o painel alvo √© de costas, o IP-Adapter tende a desenhar o rosto na nuca do personagem, pois ele opera por correla√ß√£o global de features, n√£o por correspond√™ncia sem√¢ntica.Amn√©sia Temporal (Flickering):Cada p√°gina √© gerada independentemente. O modelo "esquece" a ilumina√ß√£o (ex: luz de fogueira) usada no painel anterior, criando descontinuidades visuais severas em sequ√™ncias narrativas.2. A Solu√ß√£o: Arquitetura PCTCO sistema PCTC (Point Correspondence & Temporal Consistency) introduz duas camadas de intelig√™ncia no Pass 1 (An√°lise) que guiam a gera√ß√£o no Pass 2:2.1 Semantic Mapping (LightGlue + Attention Masks)Em vez de deixar o IP-Adapter "adivinhar" onde aplicar a identidade, usamos LightGlue para encontrar correspond√™ncias exatas de keypoints entre a Refer√™ncia e o Line Art (ex: "Ponta do nariz na Ref" $\leftrightarrow$ "Ponta do nariz no Line Art").Mudan√ßa Arquitetural Cr√≠tica:Ao contr√°rio da proposta inicial, n√£o alteraremos os Latents. Os keypoints ser√£o convertidos em Mapas de Calor (Heatmaps) e injetados diretamente no mecanismo de Cross-Attention da UNet.2.2 Consist√™ncia Temporal Condicional (H√≠brido RAFT/AdaIN)O sistema analisa a transi√ß√£o entre a P√°gina N-1 e a P√°gina N:Cena Cont√≠nua (Overlap > 30%): Usa RAFT (Optical Flow) para deformar (warp) as cores da p√°gina anterior para a atual.Mudan√ßa de Cena (Overlap < 30%): Usa Histogram Matching / AdaIN para manter a paleta de cores global sem tentar alinhar pixels geometricamente (evitando artefatos de deforma√ß√£o).3. Especifica√ß√£o T√©cnica3.1 Fluxo de Dados (Pipeline)Snippet de c√≥digograph TD
    subgraph PASS 1: CPU Analysis
        A[Reference Image] & B[Target Line Art] --> C{LightGlue Matcher}
        C -->|Keypoints| D[Attention Map Generator]
        D --> E[Gaussian Attention Masks]
        
        F[Prev Page Color] & B --> G{Scene Change Detector}
        G -- High Overlap --> H[RAFT Optical Flow]
        G -- Low Overlap --> I[Histogram/AdaIN Transfer]
        H & I --> J[Color Hint Map]
    end

    subgraph PASS 2: GPU Generation
        K[SDXL UNet]
        L[IP-Adapter AttnProcessor]
        
        E -->|Argument: ip_adapter_masks| L
        J -->|ControlNet / Img2Img Init| K
        
        A -->|CLIP Image Encoder| M[Image Embeds]
        M --> L
        L --> K
    end
3.2 Componentes a ImplementarA. PointCorrespondenceService (core/analysis/point_matching.py)Respons√°vel por gerar as m√°scaras de aten√ß√£o que dizem ao modelo "o que vai onde".Entrada: Imagem de Refer√™ncia, Crop do Personagem (Line Art).Processo:Extra√ß√£o de Features (SuperPoint).Matching (LightGlue).Filtragem de confian√ßa (> 0.5).Gera√ß√£o de Heatmaps Gaussianos (128x128).Sa√≠da: Tensor [1, H, W] (Attention Mask).Hardware: CPU (OnnxRuntime/Quantized) para preservar VRAM.B. TemporalConsistencyService (core/analysis/temporal_flow.py)Respons√°vel por decidir qual estrat√©gia de continuidade usar.L√≥gica:Pythonif calculate_ssim(prev_line, current_line) > THRESHOLD:
    hint = apply_raft_flow(prev_color, flow_vector)
else:
    hint = apply_color_grading(prev_color, target_structure)
C. Modifica√ß√£o no RegionalIPAdapterAtualizar o pipeline de infer√™ncia para aceitar m√°scaras de aten√ß√£o din√¢micas.M√©todo: Utilizar o par√¢metro cross_attention_kwargs do pipeline StableDiffusionXLPipeline.Integra√ß√£o com ADR 004:A m√°scara do SAM define o recorte (Hard Mask).A m√°scara do LightGlue define o foco interno (Soft Attention).As duas s√£o combinadas ou passadas em paralelo dependendo da implementa√ß√£o do processador de aten√ß√£o.4. Estrat√©gia de Fallback e Riscos4.1 Gest√£o de VRAM (Cr√≠tico para RTX 3060)O uso de m√°scaras de aten√ß√£o aumenta o consumo de VRAM no Pass 2, pois as matrizes de aten√ß√£o (Batch x Heads x Pixels x Pixels) deixam de ser esparsas/otimizadas em alguns casos.Risco: OOM (Out of Memory) em resolu√ß√µes acima de 1024x1024.Mitiga√ß√£o:Gerar m√°scaras de aten√ß√£o em baixa resolu√ß√£o (64x64 ou 128x128) e fazer upscaling apenas na camada necess√°ria.Se detectar risco de OOM, desativar PCTC automaticamente e rodar apenas com ADR 004 (SAM).4.2 Falha de Correspond√™nciaEm poses extremas ou tra√ßos muito estilizados, o LightGlue pode n√£o encontrar pontos suficientes.Fallback: Se num_matches < 10, o sistema descarta a m√°scara de aten√ß√£o e usa o comportamento padr√£o (Global IP-Adapter), confiando apenas no recorte do SAM.5. Plano de Execu√ß√£oFase 1 (Core Logic):Implementar PointCorrespondenceService usando kornia ou lightglue (vers√£o ONNX).Criar visualizador de matches para debug.Fase 2 (Integration):Integrar sa√≠da do servi√ßo no ChapterDatabase (salvar m√°scaras compactadas ou gerar on-the-fly).Modificar Pass2Generator para injetar cross_attention_kwargs.Fase 3 (Temporal):Implementar RAFT e Histogram Matching.Integrar l√≥gica de "Scene Change" no Pass1Analyzer.6. Consequ√™nciasAspectoAntes (v2.6.4)Depois (v2.7 PCTC)Consist√™ncia Anat√¥micaAleat√≥ria (rosto nas costas)Guiada (Semanticamente correta)Transi√ß√£o de P√°ginasIndependente (Flickering)Suave (Optical Flow/Color Match)Custo Pass 1 (CPU)BaixoM√©dio (+1.5s/p√°gina)Custo Pass 2 (VRAM)~9.8 GB~10.5 GB (Aten√ß√£o redobrada)ComplexidadeM√©diaAltaEste ADR formaliza a eleva√ß√£o do projeto para o estado da arte de 2026, resolvendo os problemas de alucina√ß√£o estrutural que o SAM sozinho n√£o consegue tratar.